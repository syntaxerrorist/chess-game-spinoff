‘AdvanceGame’ is a software application that incorporates artificial intelligence capabilities to enhance gameplay for the board game called 'Advance'. Developed using C# .NET 6.0, the program utilizes 18 distinct files within a shared namespace. It leverages a code template provided by Dr. Buckingham, which was supplemented with additional content available on his OneDrive repository from week 11 onwards. The primary objective of the software is to determine and compute optimal moves for each turn, based on the given game scenario. The software reads a text file (.txt) containing the current board state and proceeds to generate an output text file that reflects a new board state. This updated state showcases the software's determination of the optimal move to play in the game.

‘Program’ class:
This represents the main program class of the 'AdvanceGame' application. It begins by checking command line arguments, and if the argument is "name", it outputs the predefined bot name. Otherwise, it expects three command line arguments: the player's colour, input file, and output file. The program loads the game state from the input file, selects the current player based on the colour, and makes a move based on the player's chosen strategy. The resulting game board is then generated and saved to the output file. Exception handling is included to handle file-related errors and other unexpected exceptions.

‘Game’ class:
The Game class serves as the core component for managing the game state in the Advance game. It encapsulates the game board, players controlling the White and Black pieces, and includes a special Wall player for wall pieces. The class provides methods to load a game board from a file, using a nested for loop (iterate through each row and column co-ordinates together per square) to assign pieces to players based on scanned characters. It also generates a game board representation, marking empty squares with a '.' icon. Additionally, it offers a string representation of the game object. Exception handling is implemented to handle file-related errors. Overall, the Game class facilitates the interaction between the game board and players, ensuring the proper management of the game state.

‘Army’ class:

The Army class represents a collection of pieces that belong to a player's army in the Advance game. It utilizes encapsulation by providing a public property Pieces to access the collection of pieces. The class has a private list ‘pieces’ to store the pieces and private properties Player and Board to reference the associated player and game board, respectively. The class employs constructor injection to initialize an Army object with a player and board. This also implements a dictionary named ‘pieceTypes’ and is utilized to associate each type of piece with its corresponding icon or symbol. This dictionary maps the character icon to the corresponding Type of the piece. It has a method AssignPiecesToPlayer() to assign pieces to the player based on the specified icon and current square, dynamically creating piece objects using Activator.Create.Instance(). Additionally, it includes a method AddPiece() to add a piece to the army by storing it in the list. 

Board’ class:
The Board class represents a game board in the Advance game, consisting of squares stored inside a 1D array. Each square is represented by the Square class, which encapsulates its properties and behaviour. The Board class initializes the squares by performing a double sweep, assigning each square its own set of row and column coordinates. It provides a Set() method to assign a specified square at the given row and column coordinates, using bounds checking to ensure the coordinates are valid. The Get() method retrieves the square at the specified row and column coordinates, returning the square or null if the coordinates are out of bounds. These methods demonstrate encapsulation by encapsulating the internal logic of accessing and modifying squares. Additionally, the Squares property provides an enumerable collection of squares, allowing external code to iterate over the squares on the board. This showcases the use of abstraction and encapsulation to provide a controlled and abstracted interface for working with the squares.

‘Square’ class:
The Square class represents a square on the game board. The class provides methods to perform operations on the square, including occupancy, removal, and retrieval of neighbouring squares. The AdjacentSquares property returns a collection of all adjacent squares, including diagonal ones, while the OrthogonalSquares property returns a collection of orthogonal neighbouring squares. The Neighbour method retrieves a specific neighbouring square based on given row and column offsets. The ThreateningPieces property determines the pieces that threaten the current square by iterating over all squares on the board and checking if their occupant pieces can attack the current square. 

‘Colour’ enum:
Not a class but defines an enumeration called Colour, which represents the colours associated with each player in the game. The Colour enum includes values for White and Black representing the colours of the two controllable players. Additionally, there is Wall value, indicating that walls in the game are assigned to a separate non-controllable player with the colour 'Wall'.

‘Player’ class:
The Player class represents a player in the game and serves as a container for the player's attributes, including their colour, army composition, and the associated game instance. It offers a set of methods and properties that enable interaction and manipulation of player-specific information. This class also includes three key methods that allow the AI to determine which move to play namely, ChooseMove(), CheckGeneral() and BestMove().
The ChooseMove() method in the Player class analyses possible actions and selects the best move for the player. It first generates a list of potential actions based on the player's available pieces and the game board's state. It then checks if the player's general is under threat for each possible action, removing actions that endanger the general.
The CheckGeneral() method is responsible for examining each potential action and determining if it puts the general at risk. It creates a copy of the player's piece list and iterates through the possible actions in reverse order. It temporarily performs each action, checks if the general is threatened, and removes the action from the list if it endangers the general. This ensures that only safe actions remain for consideration.
The BestMove() method evaluates the remaining possible actions and selects the one with the highest score. It iterates through each action, temporarily performs it, and calculates its current score. If a lookahead depth is specified and greater than zero, it recursively evaluates the opponent's moves by calling ChooseMove() for the opponent with a reduced lookahead value. If the opponent has no available action, the current action is returned. After evaluating the opponent's move, the action is undone. The method then compares the current score with the previous best score and updates the best move if the current score is higher. Finally, it returns the action with the highest score as the best move for the player.

‘Action’ class:
This class provides a framework for implementing and executing various game actions in a board game, allowing for movement, attacks, conversions, swaps, wall-building, and wall destruction. The main class is Action, an abstract base class representing a generic game action. It is inherited by specific action classes such as Move, Attack, Convert, Swap, BuildWall, and DestroyWall. This code demonstrates polymorphism and code reuse through inheritance, allowing different game actions to be treated as instances of the base Action class. It also utilizes interfaces and abstraction to define a common contract for action behaviour.

‘Piece’ class:
The provided code defines an abstract base class Piece for game pieces in a board game. It includes properties for the owning player and occupied square, and methods for movement, attacking, and Sentinel protection checks. Derived classes implement specific piece behaviours. Utility methods retrieve player and square information, and there's a field for conversion capability. This code forms a foundation for creating game pieces with distinct characteristics on the board.

Piece sub-classes --> Builder, Catapult, Dragon, General, Jester, Miner, Sentinel, Wall and Zombie:

These are all the 9 different pieces which are owned by each player in the game of Advance. They all inherit properties from the base class and also have their own unique functionalities implemented through abstract methods. Furthermore, this is where the implementation is defined for how each piece can navigate and move on the game board. The CanAttack() method determines if a piece can perform an attack on a target square by retrieving information of the target square via the Square class. The CanMove() method operates similarly but instead only checks for valid moves without considering attacks. The returned value from the CanMove() method is utilized within the CanAttack() method as supplementary information to determine the feasibility of an attack. Lastly, the CanSwap() method returns false for every single piece except for the Jester since it is the only piece that can legally perform the swap action. These are called inside the Player class when choosing a valid move in ChooseMove()	. If these methods return true for a given piece, then it adds it to the possibleActions list. If false, then no legal moves are allowed for that action.
